//> =================
//> dom.js

const dom = {}
/**
 * @param  {string} text
 * @returns {Text}
 */
dom.newTextNode = (text) => {
	return document.createTextNode(text);
};



/**
 * creats a html tag
 *
 * @param  {string} tagName
 * @param  {Object} settings
 * @param  {string} css
 * @return {HTMLElement} new HTMLElement tag
 */
dom.newTag = (tagName, settings, css) => {
	settings = settings || {};
	const tag = document.createElement(tagName);
	for(let attr in settings){
		if(attr != "text"){
			tag[attr] = settings[attr];
		}
	}
	if(settings.text){
		tag.textContent = settings.text;
	}else if(settings.childElement){
		if(typeof settings.childElement === "object"){
			//if childNodes NodeList is passed in
			if(settings.childElement instanceof NodeList){
				//NodeList is does not inherit from array
				Array.prototype.slice.call(settings.childElement,0).forEach((childNode) => {
					tag.appendChild(childNode);
				});
			}else{
				tag.appendChild(settings.childElement);
			}
		}else{
			tag.appendChild(dom.newTextNode(settings.childElement));
		}
	}
	if(settings.class){
		tag.className = settings.class;
	}
	if ( css ) tag.style.cssText = css;
	return tag;
};

/**
 * Helper to create a table
 *
 * @param  {string} id - id of holder
 * @param  {function} headerBuilder
 * @param  {function} rowBuilder
 * @returns {HTMLDivElement} `table` wrapped in a holder `div`
 */
dom.tableFactory = (id, headerBuilder, rowBuilder) => {
	const tableHolder = dom.newTag("div", {
		id : id || "",
		class : "table-holder"
	});
	const table = dom.newTag("table");
	const thead = dom.newTag("thead");

	thead.appendChild(headerBuilder(dom.newTag("tr")));
	table.appendChild(thead);
	table.appendChild(rowBuilder(dom.newTag("tbody")));
	tableHolder.appendChild(table);
	return tableHolder;
};

/**
 * Combines 2 nodes into a wrapper `div`
 *
 * @param  {Element|string} a - fist node
 * @param  {Element|string} b - second node
 * @returns {HTMLDivElement}
 */
dom.combineNodes = (a, b) => {
	const wrapper = document.createElement("div");
	if(typeof a === "object"){
		wrapper.appendChild(a);
	}else if(typeof a === "string"){
		wrapper.appendChild(dom.newTextNode(a));
	}
	if(typeof b === "object"){
		wrapper.appendChild(b);
	}else if(typeof b === "string"){
		wrapper.appendChild(dom.newTextNode(b));
	}
	return wrapper.childNodes;
};

/**
 * Adds CSS classname to `el`
 *
 * @param  {HTMLElement} el
 * @param  {string} className
 * @returns {HTMLElement} returns `el` again for chaining
 */
dom.addClass = (el, className) => {
	el.classList.add(className);
	return el;
};

/**
 * Removes CSS classname from `el`
 *
 * @param  {HTMLElement} el
 * @param  {string} className
 * @returns {HTMLElement} returns `el` again for chaining
 */
dom.removeClass = (el, className) => {
  el.classList.remove(className);
	return el;
};
//> =================
//> helpers.js



const helper = {};

//extract a resources file type
helper.getFileType = (fileExtension, initiatorType) => {
	if(fileExtension){
		switch(fileExtension){
			case "jpg" :
			case "jpeg" :
			case "png" :
			case "gif" :
			case "webp" :
			case "svg" :
			case "ico" :
				return "image";
			case "js" :
				return "js"
			case "css":
				return "css"
			case "html":
				return "html"
			case "woff":
			case "woff2":
			case "ttf":
			case "eot":
			case "otf":
				return "font"
			//XX case "swf":
			//XX 	return "flash"
			case "map":
				return "source-map"
		}
	}
	if(initiatorType){
		switch(initiatorType){
			case "xmlhttprequest" :
				return "ajax"
			case "img" :
				return "image"
			case "script" :
				return "js"
			case "internal" :
			case "iframe" :
				return "html" //actual page
			default :
				return "other"
		}
	}
	return initiatorType;
};

helper.getRandomColor = (baseRangeRed, baseRangeGreen, baseRangeBlue) => {
	const range = [
		baseRangeRed||"0123456789ABCDEF",
		baseRangeGreen||"0123456789ABCDEF",
		baseRangeBlue||"0123456789ABCDEF"
	];
	let color = "#",
		r = 0;

	for (let i = 0; i < 6; i++){
		r = Math.floor(i/2);
		color += range[r].split("")[Math.floor(Math.random() * range[r].length)];
	}
	return color;
};

helper.endsWith = (str, suffix) => {
	return str.indexOf(suffix, str.length - suffix.length) !== -1;
};

const getColourVariation = (hexColour, variation) => {
	const r = ((parseInt(hexColour.substr(1,2), 16)) + variation).toString(16),
		g = ((parseInt(hexColour.substr(3,2), 16)) + variation).toString(16),
		b = ((parseInt(hexColour.substr(5,2), 16)) + variation).toString(16);
	return "#" + r + g + b;
}

helper.getInitiatorOrFileTypeColour = (initiatorOrFileType, fallbackColour, variation) => {
	let colour = fallbackColour||"#bebebe"; //default

	//colour the resources by initiator or file type
	switch(initiatorOrFileType) {
		case "css" : colour = "#6b7ac7"; break;
		case "iframe" :
		case "html" : colour = "#b86bc7"; break;
		case "img" :
		case "image" : colour = "#c78a6b"; break;
		case "script" :
		case "js" : colour = "#8a6bc7"; break;
		case "link" : colour = "#6bc7b8"; break;
		//XX case "swf" : colour = "#4db3ba"; break;
		case "font" : colour = "#6ba8c7"; break; //TODO check if this works
		case "xmlhttprequest" :
		case "ajax" : colour = "#c76b8a"; break;
	}
	if(variation === true){
		return getColourVariation(colour, -5);
	}
	return colour;
};

//counts occurrences of items in array arr and returns them as array of key valure pairs
//keyName overwrites the name of the key attribute
helper.getItemCount = (arr, keyName) => {
	let counts = {},
		resultArr = [],
		obj;

	arr.forEach((key) => {
		counts[key] = counts[key] ? counts[key]+1 : 1;
	});

	//pivot data
	for(let fe in counts){
		obj = {};
		obj[keyName||"key"] = fe;
		obj.count = counts[fe];

		resultArr.push(obj);
	}
	return resultArr.sort((a, b) => {
		return a.count < b.count ? 1 : -1;
	});
};

helper.clone = (obj) => {
	let copy;

	// Handle the 3 simple types, and null or undefined
	if (null == obj || "object" != typeof obj) return obj;

	// Handle Date
	if (obj instanceof Date) {
		copy = new Date();
		copy.setTime(obj.getTime());
		return copy;
	}

	// Handle Array
	if (obj instanceof Array) {
		copy = [];
		for (let i = 0, len = obj.length; i < len; i++) {
			copy[i] = helper.clone(obj[i]);
		}
		return copy;
	}

	// Handle Object
	if (obj instanceof Object) {
		copy = {};
		for (let attr in obj) {
			if (obj.hasOwnProperty(attr)) copy[attr] = helper.clone(obj[attr]);
		}
		return copy;
	}

	throw new Error("Unable to helper.clone obj");
};
//> =================
//> data.js

let isValid = true;

const data =
{
	resources: [],
	marks: [],
	measures: [],
	perfTiming: [],
	allResourcesCalc: [],
	isValid : () => isValid
};

const supportsFeatures = () => {
	//Check if the browser suppots the timing APIs
	if(window.performance && window.performance.getEntriesByType !== undefined) {
		data.resources = window.performance.getEntriesByType("resource");
		data.marks = window.performance.getEntriesByType("mark");
		data.measures = window.performance.getEntriesByType("measure");
	}else if(window.performance && window.performance.webkitGetEntriesByType !== undefined) {
		data.resources = window.performance.webkitGetEntriesByType("resource");
		data.marks = window.performance.webkitGetEntriesByType("mark");
		data.measures = window.performance.webkitGetEntriesByType("measure");
	}else{
		alert("Oups, looks like this browser does not support the Resource Timing API\ncheck http://caniuse.com/#feat=resource-timing to see the ones supporting it \n\n");
		return false;
	}

	if(window.performance.timing){
		data.perfTiming = window.performance.timing;
	}else{
		alert("Oups, looks like this browser does not support performance timing");
		return false;
	}

	if(data.perfTiming.loadEventEnd - data.perfTiming.navigationStart < 0){
		alert("Page is still loading - please try again when page is loaded.");
		return false;
	}
	return true;
};


void function ()
{
	isValid = supportsFeatures();


	data.allResourcesCalc = data.resources
		//remove this bookmarklet from the result
		.filter((currR) => !currR.name.match(/http[s]?\:\/\/(micmro|nurun).github.io\/performance-bookmarklet\/.*/))
		.map((currR, i, arr) => {
			//crunch the resources data into something easier to work with
			const isRequest = currR.name.indexOf("http") === 0;
			let  urlFragments, maybeFileName, fileExtension;

			if(isRequest){
				urlFragments = currR.name.match(/:\/\/(.[^/]+)([^?]*)\??(.*)/);
				maybeFileName = urlFragments[2].split("/").pop();
				fileExtension = maybeFileName.substr((Math.max(0, maybeFileName.lastIndexOf(".")) || Infinity) + 1);
			}else{
				urlFragments = ["", location.host];
				fileExtension = currR.name.split(":")[0];
			}

			const currRes = {
				name : currR.name,
				domain : urlFragments[1],
				initiatorType : currR.initiatorType || fileExtension || "SourceMap or Not Defined",
				fileExtension : fileExtension || "XHR or Not Defined",
				loadtime : currR.duration,
				fileType : helper.getFileType(fileExtension, currR.initiatorType),
				isRequestToHost : urlFragments[1] === location.host
			};

			for(let attr in currR){
				if(typeof currR[attr] !== "function") {
					currRes[attr] = currR[attr];
				}
			}

			if(currR.requestStart){
				currRes.requestStartDelay = currR.requestStart - currR.startTime;
				currRes.dns = currR.domainLookupEnd - currR.domainLookupStart;
				currRes.tcp = currR.connectEnd - currR.connectStart;
				currRes.ttfb = currR.responseStart - currR.startTime;
				currRes.requestDuration = currR.responseStart - currR.requestStart;
			}
			if(currR.secureConnectionStart){
				currRes.ssl = currR.connectEnd - currR.secureConnectionStart;
			}

			return currRes;
		});

	//filter out non-http[s] and sourcemaps
	data.requestsOnly = data.allResourcesCalc.filter((currR) => {
		return currR.name.indexOf("http") === 0 && !currR.name.match(/js.map$/);
	});


	//get counts
	data.initiatorTypeCounts = helper.getItemCount(data.requestsOnly.map((currR, i, arr) => {
		return currR.initiatorType || currR.fileExtension;
	}), "initiatorType");

	data.initiatorTypeCountHostExt = helper.getItemCount(data.requestsOnly.map((currR, i, arr) => {
		return (currR.initiatorType  || currR.fileExtension) + " " + (currR.isRequestToHost ? "(host)" : "(external)");
	}), "initiatorType");

	data.requestsByDomain = helper.getItemCount(data.requestsOnly.map((currR, i, arr) => currR.domain), "domain");

	data.fileTypeCountHostExt = helper.getItemCount(data.requestsOnly.map((currR, i, arr) => {
		return currR.fileType  + " " + (currR.isRequestToHost ? "(host)" : "(external)");
	}), "fileType");

	data.fileTypeCounts = helper.getItemCount(data.requestsOnly.map((currR, i, arr) => currR.fileType), "fileType");

	const tempResponseEnd = {};
	//TODO: make immutable
	data.requestsOnly.forEach((currR) => {
		const entry = data.requestsByDomain.filter((a) => a.domain == currR.domain)[0]||{};

		const lastResponseEnd = tempResponseEnd[currR.domain]||0;

		currR.duration = entry.duration||(currR.responseEnd - currR.startTime);

		if(lastResponseEnd <= currR.startTime){
			entry.durationTotalParallel = (entry.durationTotalParallel||0) + currR.duration;
		} else if (lastResponseEnd < currR.responseEnd){
			entry.durationTotalParallel = (entry.durationTotalParallel||0) + (currR.responseEnd - lastResponseEnd);
		}
		tempResponseEnd[currR.domain] = currR.responseEnd||0;
		entry.durationTotal = (entry.durationTotal||0) + currR.duration;
	});


	//Request counts
	data.hostRequests = data.requestsOnly
		.filter((domain) => domain.domain === location.host).length;

	data.currAndSubdomainRequests = data.requestsOnly
		.filter((domain) => domain.domain.split(".").slice(-2).join(".") === location.host.split(".").slice(-2).join("."))
		.length;

	data.crossDocDomainRequests = data.requestsOnly
		.filter((domain) => !helper.endsWith(domain.domain, document.domain)).length;

	data.hostSubdomains = data.requestsByDomain
		.filter((domain) => helper.endsWith(domain.domain, location.host.split(".").slice(-2).join(".")) && domain.domain !== location.host)
		.length;


	data.slowestCalls = [];
	data.average = undefined;

	if(data.allResourcesCalc.length > 0){
		data.slowestCalls = data.allResourcesCalc
			.filter((a) => a.name !== location.href)
			.sort((a, b) => b.duration - a.duration);

		data.average = Math.floor(data.slowestCalls.reduceRight((a,b) => {
			if(typeof a !== "number"){
				return a.duration + b.duration
			}
			return a + b.duration;
		}) / data.slowestCalls.length);
	}
} ()

//> =================
//> svg.js

const svg = {}

/**
 * Create new SVG element
 *
 * @param  {string} tagName
 * @param  {Object} settings
 * @param  {string} css
 */
svg.newEl = (tagName, settings, css) => {
	const el = document.createElementNS("http://www.w3.org/2000/svg", tagName);
	settings = settings || {};
	for(let attr in settings) if(attr != "text") el.setAttribute(attr, settings[attr]);
	el.textContent = settings.text||"";
	if ( css ) el.style.cssText = css
	return el;
};


/**
 * Creates a new SVG `text` element
 *
 * @param  {string} text
 * @param  {number} y
 * @param  {string} css
 * @returns {SVGTextElement}
 */
svg.newTextEl = (text, y, css) => {
	return svg.newEl("text", {
			fill : "#111",
			y : y,
			text : text
		}, (css||""))
};

/**
 * Calculates the with of a SVG `text` element
 *
 * _needs access to iFrame, since width depends on context_
 *
 * @param  {SVGTextElement} textNode
 * @returns {number} width of `textNode`
 */
svg.getNodeTextWidth = (textNode) => {
	const tmp = svg.newEl("svg", {}, "visibility:hidden;");    // EDITED svg:svg
	tmp.appendChild(textNode);
	iFrameHolder.getOutputIFrame().body.appendChild(tmp);

	const nodeWidth = textNode.getBBox().width;
	tmp.parentNode.removeChild(tmp);
	return nodeWidth;
};
//> =================
//> waterfall.js


const waterfall = {};


//model for block and segment
waterfall.timeBlock = (name, start, end, cssClass, segments, rawResource) => {
	return {
		name : name,
		start : start,
		end : end,
		total : ((typeof start !== "number" || typeof end !== "number") ? undefined : (end - start)),
		cssClass : cssClass,
		segments : segments,
		rawResource : rawResource
	}
};

waterfall.setupTimeLine = (durationMs, blocks, marks, lines, title) => {
	const unit = durationMs / 100,
		barsToShow = blocks
			.filter((block) => (typeof block.start == "number" && typeof block.total == "number"))
			.sort((a, b) => (a.start||0) - (b.start||0)),
		maxMarkTextLength = marks.length > 0 ? marks.reduce((currMax, currValue) => {
			return Math.max((typeof currMax == "number" ? currMax : 0), svg.getNodeTextWidth( svg.newTextEl(currValue.name, "0")));
		}) : 0,
		diagramHeight = (barsToShow.length + 1) * 32,
		chartHolderHeight = diagramHeight + maxMarkTextLength + 200;  //: EDITED

	const chartHolder = dom.newTag("section", {
		class : "resource-timing water-fall-holder chart-holder"
	});
	const timeLineHolder = svg.newEl("svg", {    //EDITED: svg:svg
		height : Math.floor(chartHolderHeight),
		class : "water-fall-chart"
	});
	const timeLineLabelHolder = svg.newEl("g", {class : "labels"});

	const endLine = svg.newEl("line", {
		x1 : "0",
		y1 : "0",
		x2 : "0",
		y2 : diagramHeight,
		class : "line-end"
	});

	const startLine = svg.newEl("line", {
		x1 : "0",
		y1 : "0",
		x2 : "0",
		y2 : diagramHeight,
		class : "line-start"
	});

	const onRectMouseEnter = (evt) => {
		const targetRect = evt.target;
		dom.addClass(targetRect, "active");

		const xPosEnd = targetRect.x.baseVal.valueInSpecifiedUnits + targetRect.width.baseVal.valueInSpecifiedUnits + "%";
		const xPosStart = targetRect.x.baseVal.valueInSpecifiedUnits + "%";

		endLine.x1.baseVal.valueAsString = xPosEnd;
		endLine.x2.baseVal.valueAsString = xPosEnd;
		startLine.x1.baseVal.valueAsString = xPosStart;
		startLine.x2.baseVal.valueAsString = xPosStart;
		dom.addClass(endLine, "active");
		dom.addClass(startLine, "active");

		targetRect.parentNode.appendChild(endLine);
		targetRect.parentNode.appendChild(startLine);
	};

	const onRectMouseLeave = (evt) => {
		dom.removeClass(evt.target, "active");
		dom.removeClass(endLine, "active");
		dom.removeClass(startLine, "active");
	};

	const createRect = (width, height, x, y, cssClass, label, segments) => {
		let rectHolder;
		const rect = svg.newEl("rect", {
			width : (width / unit) + "%",
			height : height-1,
			x :  Math.round((x / unit)*100)/100 + "%",
			y : y,
			class : ((segments && segments.length > 0 ? "time-block" : "segment")) + " " +  (cssClass || "block-undefined")
		});
		if(label){
			rect.appendChild(svg.newEl("title", {
				text : label
			})); // Add tile to wedge path
		}

		rect.addEventListener("mouseenter", onRectMouseEnter);
		rect.addEventListener("mouseleave", onRectMouseLeave);

		if(segments && segments.length > 0){
			rectHolder = svg.newEl("g");
			rectHolder.appendChild(rect);
			segments.forEach((segment) => {
				if(segment.total > 0 && typeof segment.start === "number"){
					rectHolder.appendChild(createRect(segment.total, 8, segment.start||0.001, y, segment.cssClass, segment.name + " (" + Math.round(segment.start) + "ms - " +  Math.round(segment.end) + "ms | total: " + Math.round(segment.total) + "ms)"));
				}
			});
			return rectHolder;
		}else{
			return rect;
		}
	};

	const createBgRect = (block) => {
		const rect = svg.newEl("rect", {
			width : ((block.total||1) / unit) + "%",
			height : diagramHeight,
			x :  ((block.start||0.001) / unit) + "%",
			y : 0,
			class : block.cssClass || "block-undefined"
		});

		rect.appendChild(svg.newEl("title", {
			text : block.name
		})); // Add tile to wedge path
		return rect;
	};

	const createTimeWrapper = () => {
		const timeHolder = svg.newEl("g", { class : "time-scale full-width" });
		for(let i = 0, secs = durationMs / 1000, secPerc = 100 / secs; i <= secs; i++){
			const lineLabel = svg.newTextEl(i + "sec",  diagramHeight);
			if(i > secs - 0.2){
				lineLabel.setAttribute("x", secPerc * i - 0.5 + "%");
				lineLabel.setAttribute("text-anchor", "end");
			}else{
				lineLabel.setAttribute("x", secPerc * i + 0.5 + "%");
			}

			const lineEl = svg.newEl("line", {
				x1 : secPerc * i + "%",
				y1 : "0",
				x2 : secPerc * i + "%",
				y2 : diagramHeight
			});
			timeHolder.appendChild(lineEl);
			timeHolder.appendChild(lineLabel);
		}
		return timeHolder;
	};


	const renderMarks = () => {
		const marksHolder = svg.newEl("g", {
			transform : "scale(1, 1)",
			class : "marker-holder"
		});

		marks.forEach((mark, i) => {
			const x = mark.startTime / unit;
			const markHolder = svg.newEl("g", {
				class : "mark-holder"
			});
			const lineHolder = svg.newEl("g", {
				class : "line-holder"
			});
			const lineLabelHolder = svg.newEl("g", {
				class : "line-label-holder",
				x : x + "%"
			});
			mark.x = x;
			const lineLabel = svg.newTextEl(mark.name,  diagramHeight + 50 );
			//lineLabel.setAttribute("writing-mode", "tb");
			lineLabel.setAttribute("x", x + "%");
			//lineLabel.setAttribute("stroke", "");


			lineHolder.appendChild(svg.newEl("line", {
				x1 : x + "%",
				y1 : 0,
				x2 : x + "%",
				y2 : diagramHeight
			}));

			if(marks[i-1] && mark.x - marks[i-1].x < 1){
				lineLabel.setAttribute("x", marks[i-1].x+1 + "%");
				mark.x = marks[i-1].x+1;
			}

			//would use polyline but can't use percentage for points
			lineHolder.appendChild(svg.newEl("line", {
				x1 : x + "%",
				y1 : diagramHeight,
				x2 : mark.x + "%",
				y2 : diagramHeight + 23
			}));

			let isActive = false;
			const onLabelMouseEnter = (evt) => {
				if(!isActive){
					isActive = true;
					dom.addClass(lineHolder, "active");
					//firefox has issues with this
					markHolder.parentNode.appendChild(markHolder);
				}
			};

			const onLabelMouseLeave = (evt) => {
				isActive = false;
				dom.removeClass(lineHolder, "active");
			};

			lineLabel.addEventListener("mouseenter", onLabelMouseEnter);
			lineLabel.addEventListener("mouseleave", onLabelMouseLeave);
			lineLabelHolder.appendChild(lineLabel);

			markHolder.appendChild(svg.newEl("title", {
				text : mark.name + " (" + Math.round(mark.startTime) + "ms)",
			}));
			markHolder.appendChild(lineHolder);
			marksHolder.appendChild(markHolder);
			markHolder.appendChild(lineLabelHolder);
		});

		return marksHolder;
	};

	timeLineHolder.appendChild(createTimeWrapper());
	timeLineHolder.appendChild(renderMarks());

	lines.forEach((block, i) => {
		timeLineHolder.appendChild(createBgRect(block));
	});

	barsToShow.forEach((block, i) => {
		const blockWidth = block.total||1;

		const y = 25 * i;
		timeLineHolder.appendChild(createRect(blockWidth, 25, block.start||0.001, y, block.cssClass, block.name + " (" + block.start + "ms - " + block.end + "ms | total: " + block.total + "ms)", block.segments));

		const blockLabel = svg.newTextEl(block.name + " (" + Math.round(block.total) + "ms)", (y + (block.segments? 20 : 17)));

		if(((block.total||1) / unit) > 10 && svg.getNodeTextWidth(blockLabel) < 200){
			blockLabel.setAttribute("class", "inner-label");
			blockLabel.setAttribute("x", ((block.start||0.001) / unit) + 0.5 + "%");
			blockLabel.setAttribute("width", (blockWidth / unit) + "%");
		}else if(((block.start||0.001) / unit) + (blockWidth / unit) < 80){
			blockLabel.setAttribute("x", ((block.start||0.001) / unit) + (blockWidth / unit) + 0.5 + "%");
		}else {
			blockLabel.setAttribute("x", (block.start||0.001) / unit - 0.5 + "%");
			blockLabel.setAttribute("text-anchor", "end");
		}
		blockLabel.style.opacity = block.name.match(/js.map$/) ? "0.5" : "1";
		timeLineLabelHolder.appendChild(blockLabel);
	});

	timeLineHolder.appendChild(timeLineLabelHolder);

	if(title){
		chartHolder.appendChild(dom.newTag("h1", {
			text : title
		}));
	}
	chartHolder.appendChild(timeLineHolder);

	return chartHolder;
};
//> =================
//> pieChartHelpers.js


const pieChartHelpers = {};

const unit = (Math.PI * 2) / 100;

const createWedge = (id, size, startAngle, percentage, labelTxt, colour) => {
	const radius = size/2,
		endAngle = startAngle + (percentage * unit - 0.001),
		labelAngle = startAngle + (percentage/2 * unit - 0.001),
		x1 = radius + radius * Math.sin(startAngle),
		y1 = radius - radius * Math.cos(startAngle),
		x2 = radius + radius * Math.sin(endAngle),
		y2 = radius - radius * Math.cos(endAngle),
		x3 = radius + radius * 0.85 * Math.sin(labelAngle),
		y3 = radius - radius * 0.85 * Math.cos(labelAngle),
		big = (endAngle - startAngle > Math.PI) ? 1 : 0;

	const d = "M " + radius + "," + radius +	// Start at circle center
			" L " + x1 + "," + y1 +				// Draw line to (x1,y1)
			" A " + radius + "," + radius +	// Draw an arc of radius r
			" 0 " + big + " 1 " +				// Arc details...
			x2 + "," + y2 +						// Arc goes to to (x2,y2)
			" Z";								// Close path back to (cx,cy)

	const path = svg.newEl("path", {
		id : id,
		d : d,
		fill : colour
	});

	path.appendChild(svg.newEl("title", {text : labelTxt})); // Add tile to wedge path
	path.setAttribute( 'aria-labelledby', labelTxt )
	path.addEventListener("mouseenter", (evt) => {
		evt.target.style.opacity = "0.5";
		evt.target.ownerDocument.getElementById(evt.target.getAttribute("id") + "-table").style.filter = "invert(1)";
	});
	path.addEventListener("mouseleave", (evt) => {
		evt.target.style.opacity = "1";
		evt.target.ownerDocument.getElementById(evt.target.getAttribute("id") + "-table").style.filter = "none";
	});

	if(percentage > 10){
		const wedgeLabel = svg.newTextEl(labelTxt, y3);

		//first half or second half
		if(labelAngle < Math.PI){
			wedgeLabel.setAttribute("x", x3 - svg.getNodeTextWidth(wedgeLabel));
		}else{
			wedgeLabel.setAttribute("x", x3);
		}

		return { path: path, wedgeLabel: wedgeLabel, endAngle: endAngle};
	}
	return { path: path, endAngle: endAngle};
};


const chartMaxHeight = (() => {
	const contentWidth = (window.innerWidth * 0.98 - 64);
	if(contentWidth < 700){
		return 350;
	} else if(contentWidth < 800){
		return contentWidth / 2 - 72;
	} else {
		return contentWidth / 3 - 72;
	}
})();

pieChartHelpers.createPieChart = (data, size) => {
	//inspired by http://jsfiddle.net/da5LN/62/

	let startAngle = 0; // init startAngle
	const chart = svg.newEl("svg", {    //EDITED: svg:svg
			viewBox : "0 0 " + size + " " + size,
			class : "pie-chart"
		}, "max-height:"+chartMaxHeight+"px;"),
		labelWrap = svg.newEl("g", {}),
		wedgeWrap = svg.newEl("g");

	//loop through data and create wedges
	data.forEach((dataObj) => {
		const wedgeData = createWedge(dataObj.id, size, startAngle, dataObj.perc, dataObj.label + " (" + dataObj.count + ")", dataObj.colour || helper.getRandomColor());
		wedgeWrap.appendChild(wedgeData.path);
		startAngle = wedgeData.endAngle;

		if(wedgeData.wedgeLabel){
			labelWrap.appendChild(wedgeData.wedgeLabel);
		}
	});

	// foreground circle
	wedgeWrap.appendChild(svg.newEl("circle", {
		cx : size/2,
		cy : size/2,
		r : size*0.05,
		fill : "#fff"
	}));
	chart.appendChild(wedgeWrap);
	chart.appendChild(labelWrap);
	return chart;
};


pieChartHelpers.createChartTable = (title, data, columns) => {
	columns = columns || [{name: "Requests", field: "count"}];

	//create table
	return dom.tableFactory("", (thead) => {
			thead.appendChild(dom.newTag("th", {text : title, class: "text-left"}));
			columns.forEach((column) => {
				thead.appendChild(dom.newTag("th", {text : column.name, class: "text-right"}));
			});
			thead.appendChild(dom.newTag("th", {text : "Percentage", class: "text-right"}));

			return thead;
		}, (tbody) => {
			data.forEach((y) => {
				const row = dom.newTag("tr", {id : y.id + "-table"});
				row.appendChild(dom.newTag("td", {text : y.label}));
				columns.forEach((column) => {
					row.appendChild(dom.newTag("td", {text : y[column.field].toString(), class: "text-right"}));
				});
				row.appendChild(dom.newTag("td", {text : Number.parseFloat(y.perc).toPrecision(4) + "%", class: "text-right"}));
				tbody.appendChild(row);
			});
			return tbody;
	});
};
//> =================
//> pieChart.js


const pieChartComponent = {};

pieChartComponent.init = () => {

	const chartsHolder = dom.newTag("section", {
		class : "pie-charts-holder chart-holder"
	});

	// create a chart and table section
	const setupChart = (title, chartData, countTexts, columns, id) => {
		const chartHolder = dom.newTag("div", {
			class : "pie-chart-holder",
			id : id||""
		});
		chartHolder.appendChild(dom.newTag("h1", {text : title}));
		chartHolder.appendChild(pieChartHelpers.createPieChart(chartData, 400));
		chartHolder.appendChild(dom.newTag("p", {text : "Total Requests: " + data.requestsOnly.length}));
		if(countTexts && countTexts.length){
			countTexts.forEach((countText) => {
				chartHolder.appendChild(dom.newTag("p", {text : countText}));
			})
		}
		chartHolder.appendChild(pieChartHelpers.createChartTable(title, chartData, columns));
		chartsHolder.appendChild(chartHolder);
	};


	// init data for charts

	const requestsUnit = data.requestsOnly.length / 100;
	const colourRangeR = "789abcdef";
	const colourRangeG = "789abcdef";
	const colourRangeB = "789abcdef";


	//argument data
	const requestsByDomainData = data.requestsByDomain.map((sourceDomain) => {
		const domain = helper.clone(sourceDomain);
		domain.perc = domain.count / requestsUnit;
		domain.label = domain.domain;
		if(domain.domain === location.host){
			domain.colour = "#0c0";
		}else if(domain.domain.split(".").slice(-2).join(".") === location.host.split(".").slice(-2).join(".")){
			domain.colour = "#0a0";
		}else{
			domain.colour = helper.getRandomColor("56789abcdef", "01234567", "abcdef");
		}
		domain.id = "reqByDomain-" + domain.label.replace(/[^a-zA-Z]/g, "-");
		domain.durationAverage =  Math.round(domain.durationTotal / domain.count);
		domain.durationTotal =  Math.round(domain.durationTotal);
		domain.durationTotalParallel =  Math.round(domain.durationTotalParallel);
		return domain;
	});

	setupChart("Requests by Domain", requestsByDomainData, [
		"Domains Total: " + data.requestsByDomain.length
	], [
		{name:"Requests", field: "count"},
		{name: "Avg. Duration", field: "durationAverage"},
		{name: "Duration Parallel", field: "durationTotalParallel"},
		{name: "Duration Sum", field: "durationTotal"}
	], "pie-request-by-domain");

	setupChart("Requests by Initiator Type", data.initiatorTypeCounts.map((initiatorType) => {
		initiatorType.perc = initiatorType.count / requestsUnit;
		initiatorType.label = initiatorType.initiatorType;
		initiatorType.colour = helper.getInitiatorOrFileTypeColour((initiatorType.initiatorType), helper.getRandomColor(colourRangeR, colourRangeG, colourRangeB));
		initiatorType.id = "reqByInitiatorType-" + initiatorType.label.replace(/[^a-zA-Z]/g, "-");
		return initiatorType;
	}));

	setupChart("Requests by Initiator Type", data.initiatorTypeCountHostExt.map((initiatorype) => {
		const typeSegments = initiatorype.initiatorType.split(" ");
		initiatorype.perc = initiatorype.count / requestsUnit;
		initiatorype.label = initiatorype.initiatorType;
		initiatorype.colour = helper.getInitiatorOrFileTypeColour(typeSegments[0], helper.getRandomColor(colourRangeR, colourRangeG, colourRangeB), typeSegments[1] !== "(host)");
		initiatorype.id = "reqByInitiatorTypeLocEx-" + initiatorype.label.replace(/[^a-zA-Z]/g, "-");
		return initiatorype;
	}),[
		"Requests to Host: " + data.hostRequests,
		"Host: " + location.host,
	]);

	setupChart("Requests by File Type", data.fileTypeCounts.map((fileType) => {
		fileType.perc = fileType.count / requestsUnit;
		fileType.label = fileType.fileType;
		fileType.colour = helper.getInitiatorOrFileTypeColour((fileType.fileType), helper.getRandomColor(colourRangeR, colourRangeG, colourRangeB));
		fileType.id = "reqByFileType-" + fileType.label.replace(/[^a-zA-Z]/g, "-");
		return fileType;
	}));

	setupChart("Requests by File Type", data.fileTypeCountHostExt.map((fileType) => {
		const typeSegments = fileType.fileType.split(" ");
		fileType.perc = fileType.count / requestsUnit;
		fileType.label = fileType.fileType;
		fileType.colour = helper.getInitiatorOrFileTypeColour(typeSegments[0], helper.getRandomColor(colourRangeR, colourRangeG, colourRangeB), typeSegments[1] !== "(host)");
		fileType.id = "reqByFileType-" + fileType.label.replace(/[^a-zA-Z]/g, "-");
		return fileType;
	}),[
		"Requests to Host: " + data.hostRequests,
		"Host: " + location.host,
	]);


	return chartsHolder;
};
//> =================
//> summaryTiles.js


const summaryTilesComponent = {};

	summaryTilesComponent.init = function () {

		var createTile = function createTile(title, value) {
			let titleClass = ( typeof title === 'string' ) && ( title.includes( 'Requests' ) || title.includes( 'Domains' ) || title.includes( 'Subdomains' ) ) ? 'request_tile' : 'time_tile'
			if ( typeof title === 'string'  && title === 'TOTAL' ) titleClass = 'total_tile'
			var dl = dom.newTag("dl", { "class": "summary-tile " + titleClass});
			dl.appendChild(dom.newTag("dt", { childElement: title }));
			dl.appendChild(dom.newTag("dd", { childElement: value }));
			return dl;
		};
	
	const createAppendixDefValue = (a, definition, value) => {
		a.appendChild(dom.newTag("dt", {childElement : definition}));
		a.appendChild(dom.newTag("dd", {text : value}));
	};

	const tilesHolder = dom.newTag("section", {
		class : "tiles-holder chart-holder"
	});
	const appendix = dom.newTag("dl", {
		class : "summary-tile-appendix"
	});

	[
		createTile("Domains", data.requestsByDomain.length || "0"),
	  createTile("Subdomains", data.hostSubdomains || "0"),
		createTile("Requests", data.requestsOnly.length || "0"),
	  createTile("Requests to Host", data.hostRequests || "0"),
		createTile("Requests to Top & Subdomains", data.currAndSubdomainRequests || "0"),
		
	  createTile("Time to First Byte", data.perfTiming.responseStart - data.perfTiming.navigationStart),
	  createTile(dom.newTag("span", { text: "DOM Content Loading", title: "domLoading to domContentLoadedEventStart" }), data.perfTiming.domContentLoadedEventStart - data.perfTiming.domLoading),
	  createTile(dom.newTag("span", { text: "DOM Processing", title: "domLoading to loadEventStart" }), data.perfTiming.domComplete - data.perfTiming.domLoading),
	  createTile("TOTAL", data.perfTiming.loadEventEnd - data.perfTiming.navigationStart)
].forEach(tile => {
		tilesHolder.appendChild(tile);
	});

	if (data.allResourcesCalc.length > 0) {
		tilesHolder.appendChild(createTile(dom.newTag("span", { title: data.slowestCalls[0].name, text: "Slowest Call" }), Math.floor(data.slowestCalls[0].duration) ));
		tilesHolder.appendChild(createTile("Average Call", data.average));
	}

	createAppendixDefValue(appendix, dom.newTextNode("Top Level Domain", location.host.split(".").slice(-2).join(".")));
	createAppendixDefValue(appendix, dom.newTextNode("host"), location.host);
	createAppendixDefValue(appendix, dom.newTextNode("document domain"), document.domain);
	
	var connection = navigator.connection;
	if (connection) {
		createAppendixDefValue(appendix, dom.newTextNode("Navigator connection"), "");
		for (var key in connection) {
			var value = connection[key];
			if (value && typeof value != "function") {
				createAppendixDefValue(appendix, dom.newTextNode(key), value);
			}
		}
	}
	tilesHolder.appendChild(appendix);
	return tilesHolder;
};
//> =================
//> navigationTimeline.js


const navigationTimelineComponent = {};

navigationTimelineComponent.init = () => {

	const startTime = data.perfTiming.navigationStart;
	const perfTimingCalc = {
			"pageLoadTime" : data.perfTiming.loadEventEnd - data.perfTiming.navigationStart,
			"output" : []
		};

	for(let perfProp in data.perfTiming) {
		if(data.perfTiming[perfProp] && typeof data.perfTiming[perfProp] === "number"){
			perfTimingCalc[perfProp] = data.perfTiming[perfProp] - startTime;
			perfTimingCalc.output.push({
				"name" : perfProp,
				"time" : data.perfTiming[perfProp] - startTime
			});
		}
	}

	perfTimingCalc.output.sort((a, b) => (a["time"]||0) - (b["time"]||0));

	perfTimingCalc.blocks = [
		waterfall.timeBlock("Total", 0, perfTimingCalc.pageLoadTime, "block-total"),
		waterfall.timeBlock("Unload", perfTimingCalc.unloadEventStart, perfTimingCalc.unloadEventEnd, "block-unload"),
		waterfall.timeBlock("Redirect (" + performance.navigation.redirectCount + "x)", perfTimingCalc.redirectStart, perfTimingCalc.redirectEnd, "block-redirect"),
		waterfall.timeBlock("App cache", perfTimingCalc.fetchStart, perfTimingCalc.domainLookupStart, "block-appcache"),
		waterfall.timeBlock("DNS", perfTimingCalc.domainLookupStart, perfTimingCalc.domainLookupEnd, "block-dns"),
		waterfall.timeBlock("TCP", perfTimingCalc.connectStart, perfTimingCalc.connectEnd, "block-tcp"),
		waterfall.timeBlock("Time to First Byte", perfTimingCalc.requestStart, perfTimingCalc.responseStart, "block-ttfb"),
		waterfall.timeBlock("Response", perfTimingCalc.responseStart, perfTimingCalc.responseEnd, "block-response"),
		waterfall.timeBlock("DOM Processing", perfTimingCalc.domLoading, perfTimingCalc.domComplete, "block-dom"),
		waterfall.timeBlock("domContentLoaded Event", perfTimingCalc.domContentLoadedEventStart, perfTimingCalc.domContentLoadedEventEnd, "block-dom-content-loaded"),
		waterfall.timeBlock("onload Event", perfTimingCalc.loadEventStart, perfTimingCalc.loadEventEnd, "block-onload")
	];

	if(perfTimingCalc.secureConnectionStart){
		perfTimingCalc.blocks.push(waterfall.timeBlock("SSL", perfTimingCalc.connectStart, perfTimingCalc.secureConnectionStart, "block-ssl"));
	}
	if(perfTimingCalc.msFirstPaint){
		perfTimingCalc.blocks.push(waterfall.timeBlock("msFirstPaint Event", perfTimingCalc.msFirstPaint, perfTimingCalc.msFirstPaint, "block-ms-first-paint-event"));
	}
	if(perfTimingCalc.domInteractive){
		perfTimingCalc.blocks.push(waterfall.timeBlock("domInteractive Event", perfTimingCalc.domInteractive, perfTimingCalc.domInteractive, "block-dom-interactive-event"));
	}
	if(!perfTimingCalc.redirectEnd && !perfTimingCalc.redirectStart && perfTimingCalc.fetchStart > perfTimingCalc.navigationStart){
		perfTimingCalc.blocks.push(waterfall.timeBlock("Cross-Domain Redirect (and/or other Delay)", perfTimingCalc.navigationStart, perfTimingCalc.fetchStart, "block-redirect"));
	}

	perfTimingCalc.blocks.push(waterfall.timeBlock("Network/Server", perfTimingCalc.navigationStart, perfTimingCalc.responseStart, "block-network-server"));

	//add measures to be added as bars
	data.measures.forEach((measure) => {
		perfTimingCalc.blocks.push(waterfall.timeBlock("measure:" + measure.name, Math.round(measure.startTime), Math.round(measure.startTime + measure.duration), "block-custom-measure"));
	});

	tableLogger.logTables([
		{name: "Navigation Timeline", data : perfTimingCalc.blocks, columns : ["name", "start", "end", "total"]},
		{name: "Navigation Events", data : perfTimingCalc.output},
		{name: "Marks", data : data.marks, columns : ["name", "startTime", "duration"]}
	]);

	return waterfall.setupTimeLine(Math.round(perfTimingCalc.pageLoadTime), perfTimingCalc.blocks, data.marks, [], "Navigation Timing");
};
//> =================
//> resourcesTimeline.js


const resourcesTimelineComponent = {};

const getChartData = (filter) => {
	const calc = {
		pageLoadTime : data.perfTiming.loadEventEnd - data.perfTiming.responseStart,
		lastResponseEnd : data.perfTiming.loadEventEnd - data.perfTiming.responseStart,
	};


	for (let perfProp in data.perfTiming) {
		if(data.perfTiming[perfProp] && typeof data.perfTiming[perfProp] === "number"){
			calc[perfProp] = data.perfTiming[perfProp] - data.perfTiming.navigationStart;
		}
	}

	const onDomLoad = waterfall.timeBlock("domContentLoaded Event", calc.domContentLoadedEventStart, calc.domContentLoadedEventEnd, "block-dom-content-loaded");
	const onLoadEvt = waterfall.timeBlock("Onload Event", calc.loadEventStart, calc.loadEventEnd, "block-onload");
	const navigationApiTotal = [
		waterfall.timeBlock("Unload", calc.unloadEventStart, calc.unloadEventEnd, "block-unload"),
		waterfall.timeBlock("Redirect", calc.redirectStart, calc.redirectEnd, "block-redirect"),
		waterfall.timeBlock("App cache", calc.fetchStart, calc.domainLookupStart, "block-appcache"),
		waterfall.timeBlock("DNS", calc.domainLookupStart, calc.domainLookupEnd, "block-dns"),
		waterfall.timeBlock("TCP", calc.connectStart, calc.connectEnd, "block-tcp"),
		waterfall.timeBlock("Timer to First Byte", calc.requestStart, calc.responseStart, "block-ttfb"),
		waterfall.timeBlock("Response", calc.responseStart, calc.responseEnd, "block-response"),
		waterfall.timeBlock("DOM Processing", calc.domLoading, calc.domComplete, "block-dom"),
		onDomLoad,
		onLoadEvt
	];

	if(calc.secureConnectionStart){
		navigationApiTotal.push(waterfall.timeBlock("SSL", calc.connectStart, calc.secureConnectionStart, "block-ssl"));
	}
	if(calc.msFirstPaint){
		navigationApiTotal.push(waterfall.timeBlock("msFirstPaint Event", calc.msFirstPaint, calc.msFirstPaint, "block-ms-first-paint-event"));
	}
	if(calc.domInteractive){
		navigationApiTotal.push(waterfall.timeBlock("domInteractive Event", calc.domInteractive, calc.domInteractive, "block-dom-interactive-event"));
	}
	if(!calc.redirectEnd && !calc.redirectStart && calc.fetchStart > calc.navigationStart){
		navigationApiTotal.push(waterfall.timeBlock("Cross-Domain Redirect", calc.navigationStart, calc.fetchStart, "block-redirect"));
	}

	calc.blocks = [
		waterfall.timeBlock("Navigation API total", 0, calc.loadEventEnd, "block-navigation-api-total", navigationApiTotal),
	];

	data.allResourcesCalc.filter((resource) => {
			//do not show items up to 15 seconds after onload - else beacon ping etc make diagram useless
			return resource.startTime < (calc.loadEventEnd + 15000)
		})
		.filter(filter||(() => true))
		.forEach((resource, i) => {
			const segments = [
				waterfall.timeBlock("Redirect", resource.redirectStart, resource.redirectEnd, "block-redirect"),
				waterfall.timeBlock("DNS Lookup", resource.domainLookupStart, resource.domainLookupEnd, "block-dns"),
				waterfall.timeBlock("Initial Connection (TCP)", resource.connectStart, resource.connectEnd, "block-dns"),
				waterfall.timeBlock("secureConnect", resource.secureConnectionStart||undefined, resource.connectEnd, "block-ssl"),
				waterfall.timeBlock("Timer to First Byte", resource.requestStart, resource.responseStart, "block-ttfb"),
				waterfall.timeBlock("Content Download", resource.responseStart||undefined, resource.responseEnd, "block-response")
			];

			const resourceTimings = [0, resource.redirectStart, resource.domainLookupStart, resource.connectStart, resource.secureConnectionStart, resource.requestStart, resource.responseStart];

			const firstTiming = resourceTimings.reduce((currMinTiming, currentValue) => {
				if(currentValue > 0 && (currentValue < currMinTiming || currMinTiming <= 0) && currentValue != resource.startTime){
					return currentValue;
				} else {
					return currMinTiming;
				}
			});

			if(resource.startTime < firstTiming){
				segments.unshift(waterfall.timeBlock("Stalled/Blocking", resource.startTime, firstTiming, "block-blocking"));
			}

			calc.blocks.push(waterfall.timeBlock(resource.name, resource.startTime, resource.responseEnd, "block-" + resource.initiatorType, segments, resource));
			calc.lastResponseEnd = Math.max(calc.lastResponseEnd,resource.responseEnd);
		});

	return {
		loadDuration : Math.round(Math.max(calc.lastResponseEnd, (data.perfTiming.loadEventEnd-data.perfTiming.navigationStart))),
		blocks : calc.blocks,
		bg : [
			onDomLoad,
			onLoadEvt
		]
	};
};

resourcesTimelineComponent.init = () => {
	let chartData = getChartData();
	const chartHolder = waterfall.setupTimeLine(chartData.loadDuration, chartData.blocks, data.marks, chartData.bg, "Resource Timing");

	if(data.requestsByDomain.length > 1){
		const selectBox = dom.newTag("select", {
			class : "domain-selector",
			onchange : () => {
				const domain = selectBox.options[selectBox.selectedIndex].value;
				if( domain === "all"){
					chartData = getChartData();
				}else{
					chartData = getChartData((resource) => resource.domain === domain);
				}
				const tempChartHolder = waterfall.setupTimeLine(chartData.loadDuration, chartData.blocks, data.marks, chartData.bg, "Temp");
				const oldSVG = chartHolder.getElementsByClassName("water-fall-chart")[0];
				const newSVG = tempChartHolder.getElementsByClassName("water-fall-chart")[0];
				chartHolder.replaceChild(newSVG, oldSVG);
			}
		});

		selectBox.appendChild(dom.newTag("option", {
			text : "show all",
			value : "all"
		}));

		data.requestsByDomain.forEach((domain) => {
			selectBox.appendChild(dom.newTag("option", {
				text : domain.domain
			}));
		});
		const chartSvg = chartHolder.getElementsByClassName("water-fall-chart")[0];
		chartSvg.parentNode.insertBefore(selectBox, chartSvg);
	}

	return chartHolder;
};
//> =================
//> pageMetric.js


const pageMetricComponent = {};

//init UI
pageMetricComponent.init = () => {
	//persistance is off by default
	const persistanceEnabled = persistance.persistanceEnabled();

	const chartHolder = dom.newTag("section", {
		class : "page-metric chart-holder"
	});
	chartHolder.appendChild(dom.newTag("h3", {text : "Persist Data"}));

	const persistDataCheckboxLabel = dom.newTag("label", {text : " Persist Data?"});
	const persistDataCheckbox = dom.newTag("input", {
		type : "checkbox",
		id : "persist-data-checkbox",
		checked : persistanceEnabled
	});
	const printDataButton = dom.newTag("button", {text : "Dumb data to console", disabled: !persistanceEnabled});

	//hook up events
	persistDataCheckbox.addEventListener("change", (evt) => {
		const checked = evt.target.checked;
		if(checked){
			persistance.activatePersistance();
			printDataButton.disabled = false;
		}else if(window.confirm("this will wipe out all stored data")){
			persistance.deactivatePersistance();
			printDataButton.disabled = true;
		} else {
			evt.target.checked = true;
		}
	});
	persistDataCheckboxLabel.insertBefore(persistDataCheckbox, persistDataCheckboxLabel.firstChild);

	printDataButton.addEventListener("click", (evt) => {
		persistance.dump(false);
	});

	chartHolder.appendChild(persistDataCheckboxLabel);
	chartHolder.appendChild(printDataButton);

	if(persistanceEnabled){
		persistance.saveLatestMetrics();
	}

	return chartHolder;
};
//> =================
//> legends.js


const legendComponent = {};


const createLegend =
(className, title, dlArray) =>
{
	const legendHolder = dom.newTag("div", { class : "legend-holder" });
	legendHolder.appendChild(dom.newTag("h4", { text : title }));


	const ul = dom.newTag("ul", { class : "legend_color " + className });
	dlArray.forEach((definition) => {
		ul.appendChild(dom.newTag("li", { title: definition[0], style:'background-color:' + definition[1]  })); 
	});
	legendHolder.appendChild(ul);
	return legendHolder;
};


//Legend
legendComponent.init =
() =>
{
	const chartHolder = dom.newTag("section", { class : "resource-timing chart-holder" });
	chartHolder.appendChild(dom.newTag("h3", { text : "Legend" }));
	const legendsHolder = dom.newTag("div", { class : "legends-group " });

	legendsHolder.appendChild(createLegend("initiator-type-legend", "Initiator Type", [
		["link", "#6bc7b8"],
		["font", "#6ba8c7"],
		["stylesheet", "#6b7ac7"],
		["JavaScript", "#8a6bc7"],
		["iframe", "#b86bc7"],
		["img", "#c78a6b"],
		//["swf", "#4db3ba"],
		["xmlhttprequest", "#c76b8a"]
	]));

	legendsHolder.appendChild(createLegend("navigation-legend", "Navigation Timing", [
		["Redirect", "#e25336"],  // #ffff60
		["App Cache","#e2a936"],
		["DNS Lookup", "#c5e236"],
		["TCP","#36e253"],
		["SSL Negotiation","#36c5e2"],
		["Time to First Byte", "#366fe2"],
		["Content Download", "#9f8fef"],
		["DOM Processing", "#bc63e9"],
		["DOM Content Loaded", "#e236c5"],
		["On Load", "#e2366f"]
	]));

	legendsHolder.appendChild(createLegend("resource-legend", "Resource Timing", [
		["Stalled/Blocking", "#ff3344"],
		["Redirect", "#e25336"],  // #ffff60
		["App Cache","#e2a936"],
		["DNS Lookup", "#c5e236"],
		["TCP","#36e253"],
		["SSL Negotiation","#36c5e2"],
		["Initial Connection (TCP)", "#36e253"],
		["Time to First Byte", "#366fe2"],
		["Content Download", "#9f8fef"]
	]));

	chartHolder.appendChild(legendsHolder);

	return chartHolder;
};

//> =================
//> table.js


const tableComponent = {};

tableComponent.init = () => {

	const output = data.requestsOnly.reduce((collectObj, currR) => {
		let fileTypeData = collectObj[currR.fileType],
			initiatorTypeData;

		if(!fileTypeData){
			fileTypeData = collectObj[currR.fileType] = {
				"fileType" : currR.fileType,
				"count" : 0,
				"initiatorType" : {},
				"requestsToHost" : 0,
				"requestsToExternal" : 0
			};
		}

		initiatorTypeData = fileTypeData.initiatorType[currR.initiatorType];
		if(!initiatorTypeData){
			initiatorTypeData = fileTypeData.initiatorType[currR.initiatorType] = {
				"initiatorType" : currR.initiatorType,
				"count" : 0,
				"requestsToHost" : 0,
			"requestsToExternal" : 0
			}
		}

		fileTypeData.count++;
		initiatorTypeData.count++;

		if(currR.isRequestToHost){
			fileTypeData.requestsToHost++;
			initiatorTypeData.requestsToHost++;
		}else{
			fileTypeData.requestsToExternal++;
			initiatorTypeData.requestsToExternal++;
		}

		return collectObj;
	}, {});

	const sectionHolder = dom.newTag("section", {
		class : "table-section-holder chart-holder"
	});
	sectionHolder.appendChild(dom.newTag("h1", {text : "Request FileTypes & Initiators"}));


	sectionHolder.appendChild(dom.tableFactory("filetypes-and-intiators-table", (theadTr) => {
			[
				"FileType",
				"Count",
				"Count Internal",
				"Count External",
				"Initiator Type",
				"Count by Initiator Type",
				"Initiator Type Internal",
				"Initiator Type External"
			].forEach((x) => {
				theadTr.appendChild(dom.newTag("th", {
					text : x,
					width : (x.indexOf("ternal") > 0) ? "12%" : ""
				}));
			});
			return theadTr;

		}, (tbody) => {
			Object.keys(output).forEach((key, i) => {
				const fileTypeData = output[key],
					initiatorTypeKeys = Object.keys(fileTypeData.initiatorType),
					firstinitiatorTypeKey = fileTypeData.initiatorType[initiatorTypeKeys[0]],
					rowspan = initiatorTypeKeys.length;

				const tr = dom.newTag("tr", {
					class : "file-type-row " + (fileTypeData.fileType||"other") + "-light"
				});

				[
					fileTypeData.fileType,
					fileTypeData.count,
					fileTypeData.requestsToHost,
					fileTypeData.requestsToExternal,
					firstinitiatorTypeKey.initiatorType,
					firstinitiatorTypeKey.count,
					firstinitiatorTypeKey.requestsToHost,
					firstinitiatorTypeKey.requestsToExternal,

				].forEach((val, i) => {
					const settings = {
						text : val
					};
					if(i < 4 && initiatorTypeKeys.length > 1){
						settings.rowSpan = rowspan;
					}else if(i >= 4){
						settings.class = (initiatorTypeKeys[0]||"other") + "-light";

					}
					tr.appendChild(dom.newTag("td", settings));
				});

				tbody.appendChild(tr);

				initiatorTypeKeys.slice(1).forEach((initiatorTypeKey) => {
					const initiatorTypeData = fileTypeData.initiatorType[initiatorTypeKey];
					const tr2 = dom.newTag("tr", {
						class : "initiator-type-more " + (initiatorTypeKey||"other") + "-light"
					});
					tr2.appendChild(dom.newTag("td", {
						text : initiatorTypeKey
					}));
					tr2.appendChild(dom.newTag("td", {
						text : initiatorTypeData.count
					}));
					tr2.appendChild(dom.newTag("td", {
						text : initiatorTypeData.requestsToHost
					}));
					tr2.appendChild(dom.newTag("td", {
						text : initiatorTypeData.requestsToExternal
					}));

					tbody.appendChild(tr2)
				});
			});

			return tbody;
	}));

	return sectionHolder;
}
//> =================
//> persistance.js

const storageKey = "performance-bookmarklet-metrics";

const persistance = {};

const getMetrics = () => {
	return {
		timestamp: (new Date(data.perfTiming.navigationStart)).toISOString(),
		url: window.location.href,
		requests: data.requestsOnly.length,
		domains: data.requestsByDomain.length,
		subDomainsOfTld: data.hostSubdomains,
		requestsToHost: data.hostRequests,
		tldAndSubdomainRequests: data.currAndSubdomainRequests,
		total: data.perfTiming.loadEventEnd - data.perfTiming.navigationStart,
		timeToFirstByte: data.perfTiming.responseStart - data.perfTiming.navigationStart,
		domContentLoading: data.perfTiming.domContentLoadedEventStart - data.perfTiming.domLoading,
		domProcessing: data.perfTiming.domComplete - data.perfTiming.domLoading
	};
};

const getStoredValues = () => {
	return JSON.parse(localStorage.getItem(storageKey)) || [];
};

persistance.persistanceEnabled = () => {
	return !!JSON.parse(localStorage.getItem(storageKey));
};

persistance.activatePersistance = () => {
	persistance.saveLatestMetrics();
};


persistance.deactivatePersistance = () => {
	persistance.dump();
};


persistance.saveLatestMetrics = () => {
	const data = getStoredValues();
	data.push(getMetrics());
	localStorage.setItem(storageKey, JSON.stringify(data));
};


/**
* Dump the current page metrics from the data store to the console.
*
* Example:
*    PerformanceBookmarklet.PageMetric.dump(); // Dumps the data as TSV and clears the data store.
*    PerformanceBookmarklet.PageMetric.dump(false); // Dumps the data as CSV and retains the data.
*
* @param [Boolean] clear Should the data be cleared from the data store?
*/
persistance.dump = (clear = true) => {
	const sourceData = getStoredValues();

	// Nothing to analyze. Return early.
	if(sourceData.length === 0){
	  console.log("There are no page metrics. Please tick the 'Persist Data' checkbox.");
	  return;
	}

	// Remove the data from the data store.
	if(clear === true){
	  localStorage.removeItem(storageKey);
	  console.log("Storage for %s has been cleared", storageKey);
	}

	//make accessible publicly only when button is pressed
	window.PerformanceBookmarklet = {
		persistedData : sourceData
	};
	if(console.table){
		console.log("Data also accessible via %cwindow.PerformanceBookmarklet.persistedData%c:\n\n%o", "font-family:monospace", "font-family:inherit", window.PerformanceBookmarklet);
		console.table(sourceData);
	}else{
		//IE fallback
	    console.log("Data also accessible via window.PerformanceBookmarklet.persistedData");
	    console.dir(window.PerformanceBookmarklet.persistedData);
	}
};
//> =================
//> tableLogger.js
//> logger.js


const tableLogger = {};

tableLogger.logTable = (table) => {
	if(table.data.length > 0 && console.table){
		console.log("\n\n\n" + table.name + ":");
		console.table(table.data, table.columns);
	}
};

tableLogger.logTables = (tableArr) => {
	tableArr.forEach(tableLogger.logTable);
};


tableLogger.logTable({
	name : "All loaded resources",
	data : data.allResourcesCalc,
	columns : [
			"name",
			"domain",
			"fileType",
			"initiatorType",
			"fileExtension",
			"loadtime",
			"isRequestToHost",
			"requestStartDelay",
			"dns",
			"tcp",
			"ttfb",
			"requestDuration",
			"ssl"
		]
});

tableLogger.logTables([
	{
		name : "Requests by domain",
		data : data.requestsByDomain
	},
	{
		name : "Requests by Initiator Type",
		data : data.initiatorTypeCounts,
		columns : ["initiatorType", "count", "perc"]
	},
	{
		name : "Requests by Initiator Type (host/external domain)",
		data : data.initiatorTypeCountHostExt,
		columns : ["initiatorType", "count", "perc"]
	},
	{
		name : "Requests by File Type",
		data : data.fileTypeCounts,
		columns : ["fileType", "count", "perc"]
	}
]);

//> =================
//> iFrameHolder.js

/**
 * iFrame to contain perf-bookmarklet's diagrams
 * @type {HTMLIFrameElement}
 */
let iFrameEl;

/**
 * Holder element
 * @type {HTMLDivElement}
 */
let outputHolder;

/** @type {HTMLDivElement}  */
let outputContent;

/**
 * Holder document for perf-bookmarklet (in iFrame)
 * @type {Document}
 */
let outputIFrame;

/** setup iFrame overlay */
const initHolderEl = () => {
	// find or create holder element
	if (!outputHolder) {
		outputHolder = dom.newTag("div", { id: "perfbook-holder" });
		outputContent = dom.newTag("div", { id: "perfbook-content" });
		outputHolder.appendChild(outputContent);
	} else {
		outputContent = outputIFrame.getElementById("perfbook-content");
		//clear existing data
		while (outputContent.firstChild) {
			outputContent.removeChild(outputContent.firstChild);
		}
	}
};

let addComponent = (domEl) => {
	outputContent.appendChild(domEl);
};


const iFrameHolder =
{
	setup:
	() =>
	{
		//XX iFrameEl = document.getElementById("perfbook-iframe");

		const finalize =
		() =>
		{ 
			initHolderEl();
			onIFrameReady(addComponent);
			outputIFrame.body.appendChild(outputHolder);
			if (getComputedStyle(document.body).overflow != "hidden") {
				iFrameEl.style.height = (outputHolder.clientHeight + 36) + "px";
			} else {
				iFrameEl.style.height = "100%";
			}
		}

		const adopt_e = document.querySelector( '[data--=performance]' )    // //... document.body.appendChild(iFrameEl);
		iFrameEl = dom.newTag("iframe",
		{
			id: "perf_report_iframe",
			onload:
			() =>
			{
				outputIFrame = iFrameEl.contentWindow.document;
				finalize();
        adopt_e
          .appendChild( document.adoptNode( ( iFrameEl.contentDocument.body||iFrameEl.contentDocument ).children[0] ) )
				iFrameEl.remove()
			}
		} )
		adopt_e.appendChild(iFrameEl)
	},

	getOutputIFrame:
	() => outputIFrame,
}
//> =================
//> init.js

const onIFrameReady =
(addComponentFn) =>
{
	[
		summaryTilesComponent.init(),
		navigationTimelineComponent.init(),
		pieChartComponent.init(),
		tableComponent.init(),
		resourcesTimelineComponent.init(),
		legendComponent.init(),
		pageMetricComponent.init()
	].forEach((componentBody) => {addComponentFn(componentBody) })
}

iFrameHolder.setup();
