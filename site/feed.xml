<?xml version="1.0" encoding="utf-8"?> <feed xmlns="http://www.w3.org/2005/Atom"><title>typexjs</title><subtitle>TypexJS blog</subtitle><link href="https://typexjs.netlify.com/feed.xml" rel="self"/><link href="https://typexjs.netlify.com/"/><updated>2019-11-17T01:00:00+01:00</updated><id>https://typexjs.netlify.com/</id><author><name>octoxalis</name><email>octoxalis@gmail.com</email></author><entry><title>Specifiers</title><link href="https://typexjs.netlify.com/specifiers.html"/><updated>2019-11-16T01:00:00+01:00</updated><id>https://typexjs.netlify.com/specifiers.html</id><content type="html"><h1>Specifiers</h1><p data--="page_intro">About types and specificity</p><h3 id="types_specifiers">Types specifiers</h3><p><strong>TypexJS</strong> naming scheme applies to all primitive immutable types:</p><ul data--="ulist"><li>Null</li><li>Undefined</li><li>Boolean</li><li>Number</li><li>BigInt</li><li>String</li><li>Array</li><li>Object</li><li>Symbol</li></ul><p>It extends to specific Object types:</p><ul data--="ulist"><li>Class</li><li>RegExp</li><li>Function</li></ul><p>The suffix specifying the type is an underscore character followed by a single letter:</p><ul data--="ulist"><li><strong>lowercase</strong> for “wrapped” types (Boolean, Number, BigInt, String, Array, Object, Symbol, Function, Class, RegExp. See <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="noreferrer noopener">MDN Primitive description</a> ),</li><li><strong>uppercase</strong> for “unwrapped” types (Null, Undefined. )</li></ul><table class="half_width"><thead><tr><th>Type</th><th style="text-align:center">Suffix</th></tr></thead><tbody><tr><td>Null</td><td style="text-align:center">_<em>N</em></td></tr><tr><td>Undefined</td><td style="text-align:center">_<em>U</em></td></tr><tr><td>Boolean</td><td style="text-align:center">_<em>b</em></td></tr><tr><td>Number</td><td style="text-align:center">_<em>n</em></td></tr><tr><td>BigInt</td><td style="text-align:center">_<em>i</em></td></tr><tr><td>String</td><td style="text-align:center">_<em>s</em></td></tr><tr><td>Array</td><td style="text-align:center">_<em>a</em></td></tr><tr><td>Object</td><td style="text-align:center">_<em>o</em></td></tr><tr><td>Symbol</td><td style="text-align:center">_<em>y</em></td></tr><tr><td>Class</td><td style="text-align:center">_<em>c</em></td></tr><tr><td>RegExp</td><td style="text-align:center">_<em>r</em></td></tr></tbody></table><p>To convey even more meaningful information, function identifiers follow a slightly different scheme: <strong>two underscore</strong> characters before the type specifier <strong>of the returned value</strong>. Consequently, if a function doesn’t return anything (<code>void</code> function ), we use the <em>v</em> letter for its suffix!</p><table class="half_width"><thead><tr><th>Function return is</th><th style="text-align:center">Suffix</th></tr></thead><tbody><tr><td>Null</td><td style="text-align:center">__<em>N</em></td></tr><tr><td>Undefined</td><td style="text-align:center">__<em>U</em></td></tr><tr><td>Boolean</td><td style="text-align:center">__<em>b</em></td></tr><tr><td>Number</td><td style="text-align:center">__<em>n</em></td></tr><tr><td>BigInt</td><td style="text-align:center">__<em>i</em></td></tr><tr><td>String</td><td style="text-align:center">__<em>s</em></td></tr><tr><td>Array</td><td style="text-align:center">__<em>a</em></td></tr><tr><td>Object</td><td style="text-align:center">__<em>o</em></td></tr><tr><td>Symbol</td><td style="text-align:center">__<em>y</em></td></tr><tr><td>Class</td><td style="text-align:center">__<em>c</em></td></tr><tr><td>RegExp</td><td style="text-align:center">__<em>r</em></td></tr><tr><td>Function</td><td style="text-align:center">__<em>f</em></td></tr><tr><td>Void</td><td style="text-align:center">__<em>v</em></td></tr></tbody></table><p data--="example"><code>const awesome__s = () =&gt; 'An awesome String'</code></p><p data--="example"><code>const clone__s = awesome__s</code></p><p>In case of a function returning different types of value, we just omit the type character.</p><p data--="example"><code>const silly__ = string_b =&gt; string_b ? 'A weird String' : 1234</code></p><p>We could do the same for a variable accepting different kinds of type, but is it really a good practice?</p><p data--="example"><code>let hybrid_ = 'A String'</code><br/><code>hybrid_ = 1234 //: What a mess!</code></p><h3 id="full_example">Full example</h3><hgroup data--="code_ref"><h5>typexjs/source/matrix/assets/scripts/js/parts/_dom_.js</h5><h6><a href="https://prismjs.com" target="_blank" rel="noreferrer noopener" title="Highlighting provided by Prism.js">Prism</a></h6></hgroup><pre><code class="language-javascript line-numbers">
const DOM_siblings__a = selector_s =>
{
  const node_e = document.querySelector( selector_s )
  return !node_e ?
    null :
    Array.prototype.filter
      .call( node_e.parentNode.children, sibling_e => sibling_e !== node_e )
}
<br/>
const DOM_listReverse = selector_s =>
{
  const node_a = Array.prototype.slice.call(document.querySelectorAll( `${selector_s} li` ))
  node_a.forEach( node_e => node_e.parentNode.insertBefore( node_e, node_e.parentNode.firstChild ) )
}
</code></pre><p>The previous code shows an <strong>exception</strong> to the specifiers convention used by <strong>TypexJS</strong>: for <code>DOM</code> elements, it seems more appropriate to use the <code>_e</code> suffix (for <em>element</em>, because the _<em>N</em> suffix is already used for a <code>Null</code> value )than the <code>_o</code> suffix used for <code>Object</code>.</p><p>The example code shows another singularity:: we can instantly differenciate JavaScript and browser specific functions or methods from our own code functions and methods. Our identifiers have a letter suffix where JS and browser identifiers have nothing. Therefore, we can safely use exactly the same names:</p><p data--="example"><code>const myWindow = window</code><br/><code>const window_o = window // smarter isn't it?</code></p><p>Hence, everytime we want to override some JavaScript or DOM function (or any browser specific, third-party library function, etc. ), we can safely do it while keeping a semantic coherency with the original function.</p></content></entry><entry><title>Clean patch</title><link href="https://typexjs.netlify.com/patching.html"/><updated>2019-11-17T01:00:00+01:00</updated><id>https://typexjs.netlify.com/patching.html</id><content type="html"><h1>Clean patching</h1><p data--="page_intro">How to keep coherancy while patching</p><h3 id="semantic_monkey">Semantic monkey</h3><p>A useful application of TypexJS naming scheme is when we want to <a href="https://www.audero.it/blog/2016/12/05/monkey-patching-javascript/" target="_blank" rel="noreferrer noopener">monkey patch</a> a library function, using a proxy, as we should do (there is a good discussion about <a href="https://stackoverflow.com/questions/52945683/how-can-i-cleanly-monkey-patch-a-function-in-javascript/52945922#52945922" target="_blank" rel="noreferrer noopener">different ways</a> of doing it: the following example is extracted from its proxy case. ):</p><hgroup data--="code_ref"><h5>stackoverflow.com: how-can-i-cleanly-monkey-patch-a-function-in-javascript</h5><h6><a href="https://prismjs.com" target="_blank" rel="noreferrer noopener" title="Highlighting provided by Prism.js">Prism</a></h6></hgroup><pre><code class="language-javascript line-numbers">
const handler_o =
{
  apply ( target_o, this_o, arg_a )  //: target_o and this_o aren't used here
  {
    console.log( `patched function is invoked with arguments: ${arg_a}` )
    Reflect.apply( ...arguments )
  }
}
<br/>
const log__v = arg_ =>  console.log( `log__v is invoked with argument: ${arg_}` )
const log_o = new Proxy( log__v, handler_o )
<br/>
//: Now proxy function can be invoked as:
log_o( 'Hello' )
log_o( ...['Hello'] )
log_o.call( null, 'Hello' )
log_o.apply( null, ['Hello'] )
<br/>
//: All the above invocations will print the following two lines:
//-> patched function is invoked with arguments: Hello
//-> log__v is invoked with argument: Hello
</code></pre></content></entry></feed>
